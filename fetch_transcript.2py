#!/usr/bin/env python3
import argparse
import subprocess
import tempfile
import glob
import os
import re
import sys

def main():
    parser = argparse.ArgumentParser(
        description="Fetch YouTube video metadata and transcript via yt-dlp, convert to plain text"
    )
    parser.add_argument("--video_id", required=True, help="YouTube video ID")
    parser.add_argument("--output", required=True, help="Path to output transcript file")
    args = parser.parse_args()

    video_id = args.video_id
    output_path = args.output
    video_url = f"https://www.youtube.com/watch?v={video_id}"

    print(f"[INFO] Fetching metadata for video: {video_id}")
    template = (
        "id: %(id)s\n"
        "title: %(title)s\n"
        "uploader: %(uploader)s\n"
        "channel: %(channel)s\n"
        "upload_date: %(upload_date)s\n"
        "duration: %(duration_string)s\n"
        "view_count: %(view_count)s\n"
        "like_count: %(like_count)s\n"
        "categories: %(categories)s\n"
        "tags: %(tags)s\n"
        "webpage_url: %(webpage_url)s\n"
        "description: %(description)s\n"
    )
    try:
        proc = subprocess.run(
            ["yt-dlp", "-O", template, video_url],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        metadata_str = proc.stdout.strip() + "\n"
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] yt-dlp metadata fetch failed: {e.stderr}", file=sys.stderr)
        sys.exit(1)

    print("[INFO] Detecting transcript language")
    try:
        proc = subprocess.run(
            ["yt-dlp", "-O", "%(language)s", video_url],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
        )
        lang = proc.stdout.strip()
        if not lang:
            raise ValueError("empty language code")
        primary_lang = lang.split("-")[0]
        if primary_lang != lang:
            print(f"[INFO] Using language '{lang}', normalized to '{primary_lang}'")
        else:
            print(f"[INFO] Using language: {lang}")
        lang = primary_lang
    except Exception as e:
        print(f"[WARN] Could not detect language, defaulting to 'en': {e}", file=sys.stderr)
        lang = "en"

    print("[INFO] Downloading subtitles via yt-dlp")
    with tempfile.TemporaryDirectory() as tmpdir:
        cmd = [
            "yt-dlp",
            "--write-subs",
            "--write-auto-subs",
            "--sub-langs",
            lang,
            "--skip-download",
            "--convert-subs",
            "srt",
            "-o",
            "%(id)s.%(ext)s",
            video_url,
        ]
        try:
            subprocess.run(
                cmd,
                cwd=tmpdir,
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
        except subprocess.CalledProcessError as e:
            print(f"[ERROR] yt-dlp subtitle download failed: {e.stderr}", file=sys.stderr)
            sys.exit(1)

        srt_files = glob.glob(os.path.join(tmpdir, f"{video_id}.srt"))
        if not srt_files:
            srt_files = glob.glob(os.path.join(tmpdir, "*.srt"))
        if not srt_files:
            print("[ERROR] No .srt subtitle file found", file=sys.stderr)
            sys.exit(1)
        srt_path = srt_files[0]

        print(f"[INFO] Converting subtitles to plain text: {os.path.basename(srt_path)}")
        lines = []
        prev = None
        for line in open(srt_path, encoding="utf-8"):
            line = line.rstrip("\n")
            if re.match(r"^[0-9]+$", line):  # index line
                continue
            if "-->" in line:                # timestamp
                continue
            if not line.strip():
                continue
            if line == prev:                 # <-- prevents rolling repeats
                continue
            lines.append(line)
            prev = line
 
        transcript_text = "\n".join(lines)

    print(f"[INFO] Writing output to {output_path}")
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(metadata_str)
        f.write("\n")
        f.write(transcript_text)

if __name__ == "__main__":
    main()
